---
layout: mypost
title: Working Plan
categories: [Python,Golang,面试]
---

1. Golang核心解析
1.1 数据结构深度剖析
1.1.1 Array (数组)
Go语言中的数组是一种值类型，它是一个由固定长度的、特定类型的元素组成的连续内存序列。因为长度固定，数组在性能上表现优异，但在灵活性上有所欠缺。

数组的初始化
Go提供了多种灵活的数组初始化方式。

{% raw %}

package main
import "fmt"

func main() {
  // 1. 先声明后赋值
  var intArr [3]int
  intArr[0]=10
  intArr[1]=20
  intArr[2]=30
  fmt.Println("先声明后赋值:", intArr)

  // 2. 声明并初始化
  arr2 := [3]int{1, 2, 3}
  fmt.Println("直接初始化:", arr2)
  
  // 3. 使用...自动推断长度
  arr3 := [...]int{1, 2, 3, 4, 5}
  fmt.Println("自动推断长度:", arr3)
  
  // 4. 指定索引初始化
  arr4 := [3]int{1: 10, 2: 20} // arr4[0]为零值0
  fmt.Println("指定索引初始化:", arr4)

  // 5. 二维数组
  arr6 := [3][2]int{{1, 2}, {3, 4}, {5, 6}}
  fmt.Println("二维数组:", arr6)
}



{% endraw %}

核心概念与内存模型
值传递: 这是Go数组最重要的特性。当数组作为函数参数传递时，传递的是数组的完整副本，而不是引用。这意味着在函数内部修改数组不会影响到原始数组。

指针传递: 为了避免值传递带来的性能开销，并实现在函数内修改原数组的目的，可以传递数组的指针。

{% raw %}

package main
import "fmt"

// 值传递，函数接收的是数组的副本
func test01(arr [3]int) {
	arr[0] = 66 // 只会修改副本
}

// 指针传递，函数接收的是指向原数组的指针
func test02(arr *[3]int) {
	(*arr)[0] = 88 // 修改的是原始数组
}

func main() {
  arr := [3]int{1,2,3}
  
  fmt.Println("原始数组:", arr)
  test01(arr)
  fmt.Println("值传递后:", arr) // arr没有改变
  
  test02(&arr)
  fmt.Println("指针传递后:", arr) // arr被改变
}



{% endraw %}

1.1.2 Slice (切片)
切片是Go语言的灵魂。它并非真正的动态数组，而是对底层数组一个连续片段的引用。切片提供了动态增长的能力和对数组方便的访问接口。

切片的底层实现
切片的本质是一个包含三个字段的结构体：

ptr (指针): 指向底层数组中切片指定的开始位置。

len (长度): 切片中元素的数量。

cap (容量): 从切片的开始位置到底层数组的结尾位置的长度。

由于切片共享底层数组的内存，修改一个切片会影响到另一个共享同样底层数组的切片以及数组本身。

{% raw %}

// 演示切片与底层数组的关系
a := [10]int{11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
s := a[3:7] // s = [14 15 16 17], len=4, cap=7
s[0] = 99   // 修改切片s的第一个元素
// 此时，原始数组a会变为 [11 12 13 99 15 16 17 18 19 20]



{% endraw %}

切片的动态扩容
当使用 append 函数向切片中添加元素，且其 len 超出 cap 时，Go会自动进行扩容。

扩容策略:

如果期望容量大于当前容量的两倍，则直接使用期望容量。

如果当前容量小于1024，新容量会翻倍。

如果当前容量大于等于1024，新容量会每次增加约25%。

切片的拷贝
s1 := s (浅拷贝): 两个切片变量指向同一个底层数组。

copy(s2, s) (深拷贝): copy 函数会创建一个新的底层数组，并将数据从源切片复制到目标切片。

1.1.3 Map (映射)
Map是Go中的哈希表实现，提供键值对的快速存取。它是引用类型，通过 make 函数创建。

Map的底层实现
Go的map底层是一个指向 hmap 结构体的指针。hmap 结构体管理着一系列的“桶”（bmap 结构体），用于存储键值对。

hmap: 包含元素数量 count、桶的数量（2^B）、哈希种子 hash0、指向桶数组的指针 buckets 等。

bmap (桶): 每个桶可以存放8个键值对。如果一个桶满了，Go会通过链表的方式连接一个“溢出桶”来存储更多的键值对。

并发安全: Go原生的 map 不是并发安全的。在多个goroutine同时读写时必须加锁保护。对于高并发读多写少的场景，推荐使用 sync.Map。

1.1.5 Interface (接口)
接口是Go实现抽象和多态的核心。它是一种类型，定义了一组方法的集合（方法集）。任何类型只要实现了接口中所有的方法，就被认为实现了该接口。

底层实现：空接口与非空接口
Go中的接口在底层由两种结构体表示，这取决于接口是否包含方法。

空接口 (interface{}): 不包含任何方法，可以表示任何类型的值。

底层结构为 eface，包含一个指向类型信息的指针 _type 和一个指向实际数据的指针 data。

非空接口: 包含方法定义的接口。

底层结构为 iface，包含一个指向 itab 的指针 tab 和一个指向实际数据的指针 data。itab 结构包含了接口类型、具体类型以及一个函数指针列表，用于实现动态派发。

1.1.6 Channel (通道)
Channel是Go并发编程的核心，它为Goroutine之间的通信提供了同步机制，是CSP（通信顺序进程）模型的具体实现。

底层实现原理
Channel的底层是一个 hmap 结构体指针，它内部实现了一个带锁的、类型安全的队列。

buf: 一个环形队列，用于在带缓冲的channel中存储数据。

sendq 和 recvq: 两个双向链表，分别用于存放因channel已满而阻塞的发送者goroutine和因channel为空而阻塞的接收者goroutine。

lock: 一个互斥锁，保护channel的所有操作都是并发安全的。

核心规则:

对未初始化的(nil) channel进行读写都会永久阻塞。

对已关闭的 channel进行写入会引发panic。

对已关闭的 channel进行读取，会立即返回该类型的零值。

1.2 并发与调度
1.2.2 GMP调度模型
Go的调度器实现了M:N的调度，即将M个Goroutine调度到N个操作系统线程上执行。其核心组件是G, M, P。

核心比喻：把调度系统看作一个工厂

G (Goroutine): 代表一个个待完成的任务。

P (Processor): 代表生产线，每个生产线都有一个自己的待办任务列表。

M (Machine): 代表工人（操作系统线程），工人需要绑定到一条生产线上才能开始工作。

1.2.3 三色标记法垃圾回收
Go的并发垃圾回收器使用了三色标记算法，以减少STW（Stop-The-World）的时间。

初始状态: 所有对象都是白色。

扫描开始: 从根对象（如全局变量、栈对象）出发，将可达对象标记为灰色。

并发标记: 扫描所有灰色对象，将其引用的白色对象标记为灰色，然后将自身标记为黑色。

结束: 当没有灰色对象时，所有剩余的白色对象即为垃圾，可以被回收。

2. Python核心解析
2.1 数据结构
2.1.4 字典 (Dict)
Python的字典是基于哈希表实现的，提供了平均O(1)时间复杂度的插入、删除和查找操作。

2.1.5 集合 (Set)
Python的集合在底层同样基于哈希表实现，也提供了高效的插入、删除和查找操作。

底层实现与哈希冲突
当向字典中插入一个键值对时，Python会：

计算键的哈希值。

根据哈希值确定在内部数组（哈希表）中的存储位置（槽/bucket）。

如果该位置为空，则直接存入。

如果该位置已被占用（哈希冲突），Python使用开放地址法来寻找下一个可用的空槽位。

2.2 Python魔法方法与高级特性
2.2.1 协程 (asyncio/await)
协程是用户态的轻量级线程，其调度完全由程序控制，避免了操作系统线程切换的开销，因此执行效率极高。Python通过 async/await 语法和 asyncio 库提供了对协程的原生支持。

+-------------------------------------------------+
|                    Event Loop                   |
| +-----------+     +-----------+     +-----------+ |
| |  Task 1   |     |  Task 2   |     |  Task 3   | |
| +-----------+     +-----------+     +-----------+ |
|      |                 ^                 |        |
|      v (run)           | (switch)        |        |
|  [ code... ]           +-----------------+ (await)  |
|  [ await... ] ---------+                          |
|                                                 |
+-------------------------------------------------+



Event Loop (事件循环): 协程的调度核心，负责执行任务、监听IO事件，并在任务await（等待）时切换到其他可运行的任务。

async def: 定义一个协程函数。

await: 暂停当前协程的执行，让事件循环去处理其他任务，直到等待的操作完成。

2.2.2 装饰器 (Decorator)
装饰器本质上是一个接收函数作为参数并返回一个新函数的函数。它允许我们在不修改原函数代码的情况下，为其增加额外的功能（如日志、计时、权限校验）。

            +----------------------+
            |   Original Function  |
            |       (func)         |
            +----------------------+
                     |
                     v
+------------+    (passes func)    +-----------------+
| Decorator  | -----------------> | Wrapper Function|
| (@syntax)  |                    | (returns this)  |
+------------+                    +-----------------+
                                       |
                                       v
                                [ extra logic ]
                                [ call func() ]
                                [ extra logic ]



2.2.3 垃圾回收 (GC)
Python使用引用计数为主，分代回收为辅的策略来自动管理内存。

引用计数: 每个对象都有一个引用计数器。当有新的引用指向该对象时，计数器+1；当引用被销毁时，计数器-1。当计数器为0时，对象被立即回收。

优点：实时性好。
缺点：无法解决循环引用的问题。

分代回收: 为了解决循环引用和提高效率，Python将对象分为三代（0, 1, 2）。GC会更频繁地扫描年轻代（第0代），因为大部分对象都是“朝生夕死”的。只有在年轻代回收后仍然存活的对象，才会被提升到更高代。

3. 网络协议基础
3.1 TCP三次握手与四次挥手
三次握手 (建立连接)
TCP 作为一种面向连接的可靠传输协议，其连接的建立（“握手”）过程是保证后续数据可靠传输的第一步。这个过程通过三次通信确保双方都具备收发数据的能力。

      Client                                     Server
        |                                          |
        |      SYN (seq=x) ---------------------->   |
        |                                          |
        |      <---------------------- SYN, ACK (seq=y, ack=x+1)
        |                                          |
        |      ACK (ack=y+1) -------------------->   |
        |                                          |



客户端 -> 服务器 (SYN): "你好，我想和你通信，我的初始序列号是x。"

服务器 -> 客户端 (SYN+ACK): "收到了！我也想和你通信，我的初始序列号是y，我期望你下一个发给我的是x+1。"

客户端 -> 服务器 (ACK): "好的，收到了你的确认，我下一个会发y+1给你。"

四次挥手 (断开连接)
TCP是全双工的，因此连接的每一方都必须独立地进行关闭。

      Client                                     Server
        |                                          |
        |      FIN (seq=u) ---------------------->   |
        |                                          |
        |      <-------------------------- ACK (ack=u+1)
        |                                          |
        |      <-------------------------- FIN (seq=v)
        |                                          |
        |      ACK (ack=v+1) -------------------->   |
        |                                          |



客户端 -> 服务器 (FIN): "我的数据发完了，请求关闭连接。"

服务器 -> 客户端 (ACK): "好的，收到了你的关闭请求。" (此时服务器可能还有数据没发完)

服务器 -> 客户端 (FIN): "我的数据也发完了，现在我也请求关闭。"

客户端 -> 服务器 (ACK): "好的，收到了你的关闭请求。" (客户端等待2MSL后关闭)

4. 常用中间件
4.1 Redis
Redis是一个高性能的内存键值数据库，以其丰富的数据结构和出色的性能而闻名，常用于缓存、消息队列、分布式锁等场景。

String: 最基本的数据类型，可以是字符串、整数或浮点数。

List: 双向链表，支持在两端快速添加和弹出元素，适合实现消息队列。

Set: 无序、唯一的元素集合，支持交集、并集、差集等操作。

Hash: 键值对的集合，适合存储对象信息。

Sorted Set (ZSet): 带有分数的Set，元素唯一且有序，非常适合实现排行榜。

4.2 Kafka
Kafka是一个分布式的、基于发布/订阅模式的消息流平台，以其高吞吐量、持久化和可扩展性而闻名。

核心架构
+----------+      +---------------------------------+      +-----------------+
| Producer | ---> |          Kafka Cluster          |      | Consumer Group  |
+----------+      | +---------+       +---------+   |      | +------------+  |
                  | | Broker 1  | ... | Broker N  |   |      | | Consumer 1 |  |
                  | | Topic A-P0|     | Topic A-P1|   | ---> | +------------+  |
                  | | Topic B-P0|     | Topic B-P1|   |      |                 |
                  | +---------+       +---------+   |      | +------------+  |
+----------+      +---------------------------------+      | | Consumer 2 |  |
| Producer | --------------------------------------------> | +------------+  |
+----------+                                               +-----------------+



Producer (生产者): 发布消息到指定的主题(Topic)。

Broker (代理): Kafka集群中的服务器节点，负责存储消息。

Topic (主题): 消息的逻辑分类。一个Topic可以分为多个Partition。

Partition (分区): Topic的物理分组，是实现并行处理和扩展性的关键。一个Partition内的消息是有序的。

Consumer (消费者): 从Topic订阅并处理消息。通常以Consumer Group的形式工作，组内每个Consumer负责消费不同的Partition。

4.3 RabbitMQ
RabbitMQ是一个实现了AMQP（高级消息队列协议）的消息代理（Message Broker），以其灵活的路由功能和可靠性著称。

核心概念与工作模式
+----------+     +----------------+     +-----------+     +----------+
| Producer | --> |    Exchange    | --> |   Queue   | --> | Consumer |
+----------+     +----------------+     +-----------+     +----------+
                   |       ^
                   |       | Binding
                   |       | (Routing Key)
                   +-------+


Exchange (交换机): 接收来自生产者的消息，并根据类型和路由规则将消息推送到一个或多个队列。

Direct: 根据精确的Routing Key匹配。

Fanout: 将消息广播到所有绑定的队列，忽略Routing Key。

Topic: 根据模式匹配的Routing Key（使用*和#通配符）。

Queue (队列): 存储消息的缓冲区。

Binding (绑定): 连接Exchange和Queue的规则。

4.4 Celery
Celery是一个基于Python的强大的分布式异步任务队列，它允许你在Web请求之外执行耗时的操作。

核心架构
+------------+      +---------------+      +-------------+
|            |      |               |      |             |
| Web Client | ---> | Message Broker| ---> | Celery Worker|
| (App)      |      | (Redis/RabbitMQ)|      | (Processes Tasks)|
|            |      |               |      |             |
+------------+      +---------------+      +-------------+
     ^                      |                      |
     | (gets result)        +----------------------+
     |                               | (stores result)
     +-------------------------------+
                                     v
                             +-----------------+
                             |  Result Backend |
                             | (Redis/DB/etc.) |
                             +-----------------+


生产者 (Client): 应用程序，负责调用 .delay() 或 .apply_async() 来分派任务。

消息代理 (Message Broker): 接收、存储和分发任务。RabbitMQ和Redis是最常用的选择。

消费者 (Celery Worker): 一个或多个工作进程，负责从代理处获取任务并执行它们。

结果后端 (Result Backend): 可选组件，用于存储任务的执行状态和返回值。